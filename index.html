<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Mic → PCD (Even-Hue Ring)</title>
<style>
  :root { color-scheme: dark light; }
  * { box-sizing: border-box; }
  body{
    margin:0; padding:12px; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:grid; gap:12px; min-height:100svh; grid-template-rows:auto 1fr auto;
  }
  header, footer{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  button{
    padding:12px 14px; border-radius:12px; border:1px solid #888; background:transparent; cursor:pointer;
    touch-action:manipulation;
  }
  #status{ opacity:.8 }
  .canvas-wrap{ display:grid; place-items:center; width:100%; height:100%; }
  canvas{
    max-width: min(100%, 720px);
    max-height: min(100%, 720px);
    width: 100%;
    height: auto;
    touch-action:none; /* for dragging rotation on mobile */
    border-radius: 16px;
    border: 1px solid color-mix(in oklab, currentColor 30%, transparent);
    background: transparent;
  }
  code{ background:#0001; padding:3px 6px; border-radius:6px }
</style>
</head>
<body>
  <header>
    <button id="start">Start mic</button>
    <button id="stop" disabled>Stop</button>
    <button id="resetRot" title="Reset ring rotation">Reset ring</button>
    <span id="status">Idle</span>
  </header>

  <div class="canvas-wrap">
    <canvas id="ring"></canvas>
  </div>

  <footer>
    <div><strong>PCD (C..B):</strong> <code id="pcdText">[0,0,0,0,0,0,0,0,0,0,0,0]</code></div>
  </footer>

<script type="module">
  // =========================
  // ====== CONFIG HERE ======
  // =========================
  const WINDOW_SIZE = 8192*2;   // power of 2: 2048, 4096, 8192...  try WINDOW_SIZE=8192, HOP_SIZE=2048
  const HOP_SIZE    = 2048*2;   // step between analyses (samples)
  const MIN_HZ      = 50;     // ignore rumble below
  const MAX_HZ      = 5000;   // ignore hiss above
  const REF_A4      = 440;    // tuning reference
  const SMOOTHING   = 0.6;    // 0..0.95 (visual smoothing of PCD)

  const RING = {
    innerRadiusRatio: 0.38,
    outerRadiusRatio: 0.95,
    labelRadiusRatio: 0.30,
    gapRadians: 0.02,          // small visual gap between wedges
    baseRotation: -Math.PI/2,  // C at 12 o’clock
  };

  // ===== Even-hue color palette (equal S/L, 30° steps: …60°=Y, 180°=C, 300°=M)
  const NOTE_LABELS = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const IS_BLACK    = [false,true,false,true,false,false,true,false,true,false,true,false]; // piano pattern
  const COLOR = {
    startHue: 0,  // rotate the palette if you like (e.g., 15 to sit between primaries)
    sat: 80,      // %
    light: 55     // %
  };
  const PC_HUE = i => (COLOR.startHue + i * 30) % 360;
  const SLOT_BG_ALPHA = 0.10;
  // =========================

  // ===== Utilities =====
  const hann = (N) => {
    const w = new Float32Array(N), t = 2*Math.PI/(N-1);
    for (let n=0;n<N;n++) w[n] = 0.5*(1-Math.cos(t*n));
    return w;
  };

  function fftReal(signal){
    let N=1; while (N<signal.length) N<<=1;
    const re = new Float32Array(N), im = new Float32Array(N);
    re.set(signal);
    let j=0;
    for (let i=1;i<N;i++){
      let bit=N>>1;
      for(; j & bit; bit>>=1) j^=bit;
      j^=bit;
      if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; }
    }
    for (let len=2; len<=N; len<<=1){
      const ang=-2*Math.PI/len;
      const wlenRe=Math.cos(ang), wlenIm=Math.sin(ang);
      for(let i=0;i<N;i+=len){
        let wRe=1,wIm=0;
        for(let k=0;k<len/2;k++){
          const uRe=re[i+k], uIm=im[i+k];
          const vRe=re[i+k+len/2]*wRe - im[i+k+len/2]*wIm;
          const vIm=re[i+k+len/2]*wIm + im[i+k+len/2]*wRe;
          re[i+k]=uRe+vRe;       im[i+k]=uIm+vIm;
          re[i+k+len/2]=uRe-vRe; im[i+k+len/2]=uIm-vIm;
          const nwRe=wRe*wlenRe - wIm*wlenIm;
          const nwIm=wRe*wlenIm + wIm*wlenRe;
          wRe=nwRe; wIm=nwIm;
        }
      }
    }
    const mags = new Float32Array(N/2);
    for (let i=0;i<N/2;i++) mags[i]=Math.hypot(re[i],im[i]);
    return mags;
  }

  function spectrumToPCD(mags, sampleRate, a4=440, minHz=50, maxHz=5000){
    const pcd = new Float32Array(12);
    const binHz = sampleRate/(mags.length*2);
    const minBin = Math.max(1, Math.floor(minHz/binHz));
    const maxBin = Math.min(mags.length-1, Math.floor(maxHz/binHz));
    for (let k=minBin;k<=maxBin;k++){
      const f = k*binHz;
      const midi = 69 + 12*Math.log2(f/a4);
      const pc = ((Math.round(midi)%12)+12)%12;
      const w = mags[k]*mags[k]; // power weighting
      pcd[pc]+=w;
    }
    let sum=0; for (let i=0;i<12;i++) sum+=pcd[i];
    if (sum>0) for (let i=0;i<12;i++) pcd[i]/=sum;
    return pcd;
  }

  // ===== DOM / Canvas =====
  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const resetRot = document.getElementById('resetRot');
  const statusEl = document.getElementById('status');
  const pcdText  = document.getElementById('pcdText');
  const canvas   = document.getElementById('ring');
  const ctx      = canvas.getContext('2d', { alpha: true });

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const css = canvas.getBoundingClientRect();
    canvas.width  = Math.round(css.width * dpr);
    canvas.height = Math.round(css.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  new ResizeObserver(fitCanvas).observe(canvas);

  // ===== Ring draw =====
  let userRotation = 0; // radians

  function wedgePath(cx, cy, rInner, rOuter, a0, a1){
    const p = new Path2D();
    p.arc(cx, cy, rOuter, a0, a1);
    p.arc(cx, cy, rInner, a1, a0, true);
    p.closePath();
    return p;
  }
  function pcFillColor(i){ return `hsl(${PC_HUE(i)} ${COLOR.sat}% ${COLOR.light}%)`; }
  function slotBgColor(i){ return `hsla(${PC_HUE(i)} ${COLOR.sat}% ${COLOR.light}%, ${SLOT_BG_ALPHA})`; }

  function drawRing(pcd){
    const { width, height } = canvas.getBoundingClientRect();
    const cx = width/2, cy = height/2;
    const rMin = Math.min(width, height)/2;
    const rInner = rMin * RING.innerRadiusRatio;
    const rOuter = rMin * RING.outerRadiusRatio;
    const rLabel = rMin * RING.labelRadiusRatio;

    ctx.clearRect(0,0,width,height);

    const slice = (Math.PI*2)/12;
    const gap = Math.min(RING.gapRadians, slice*0.3);

    const fontPx = Math.max(11, Math.min(18, Math.round(rMin*0.06)));
    ctx.font = `${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i=0;i<12;i++){
      const a0 = RING.baseRotation + userRotation + i*slice + gap/2;
      const a1 = a0 + slice - gap;

      // slot background
      ctx.fillStyle = slotBgColor(i);
      ctx.fill(wedgePath(cx, cy, rInner, rOuter, a0, a1));

      // active value
      const val = pcd[i];
      if (val > 0.001){
        const rVal = rInner + val*(rOuter - rInner);
        ctx.fillStyle = pcFillColor(i);
        ctx.fill(wedgePath(cx, cy, rInner, rVal, a0, a1));
      }

      // labels with halo
      const mid = (a0+a1)/2;
      const lx = cx + Math.cos(mid)*rLabel;
      const ly = cy + Math.sin(mid)*rLabel;

      ctx.lineWidth = Math.max(2, fontPx/5);
      ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.strokeText(NOTE_LABELS[i], lx, ly);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.strokeText(NOTE_LABELS[i], lx, ly);
      ctx.fillStyle = 'currentColor'; ctx.fillText(NOTE_LABELS[i], lx, ly);

      // subtle dot for black keys (keeps equal brightness across wedges)
      if (IS_BLACK[i]){
        const dotR = Math.max(2, rMin*0.01);
        ctx.beginPath();
        ctx.arc(cx + Math.cos(mid)*(rInner + (rOuter-rInner)*0.5),
                cy + Math.sin(mid)*(rInner + (rOuter-rInner)*0.5),
                dotR, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fill();
      }
    }
  }

  // ===== Drag to rotate =====
  let dragging=false, lastAngle=0;
  function pointAngle(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX ?? evt.touches?.[0]?.clientX) - rect.left;
    const y = (evt.clientY ?? evt.touches?.[0]?.clientY) - rect.top;
    const cx = rect.width/2, cy = rect.height/2;
    return Math.atan2(y - cy, x - cx);
  }
  function onPointerDown(e){ e.preventDefault(); dragging=true; lastAngle=pointAngle(e); canvas.setPointerCapture?.(e.pointerId ?? 0); }
  function onPointerMove(e){ if (!dragging) return; const a=pointAngle(e); userRotation += (a-lastAngle); lastAngle=a; drawRing(window.currentPCD); }
  function onPointerUp(e){ dragging=false; canvas.releasePointerCapture?.(e.pointerId ?? 0); }
  if ('onpointerdown' in window){
    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('pointercancel', onPointerUp);
  } else {
    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive:false});
    window.addEventListener('touchmove', onPointerMove, {passive:false});
    window.addEventListener('touchend', onPointerUp);
    window.addEventListener('touchcancel', onPointerUp);
  }
  resetRot.addEventListener('click', ()=>{ userRotation=0; drawRing(window.currentPCD); });

  // ===== Public hook =====
  window.currentPCD = new Float32Array(12);
  // window.addEventListener('pcd', e => { const pcd = e.detail; ... })

  // ===== Audio + analysis =====
  let audioContext, workletNode, micStream, running=false, sampleRate=48000;
  const workletURL = URL.createObjectURL(new Blob([`
    class Tap extends AudioWorkletProcessor {
      process(inputs){ const ch = inputs[0][0]; if (ch) this.port.postMessage(ch.slice(0)); return true; }
    }
    registerProcessor('tap', Tap);
  `], {type:'text/javascript'}));

  async function start(){
    if (running) return;
    running = true; startBtn.disabled = true; stopBtn.disabled = false; statusEl.textContent = 'Starting…';

    audioContext = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
    sampleRate = audioContext.sampleRate;
    await audioContext.audioWorklet.addModule(workletURL);

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
      video: false
    });

    const src = audioContext.createMediaStreamSource(micStream);
    const silent = audioContext.createGain(); silent.gain.value = 0;
    workletNode = new AudioWorkletNode(audioContext, 'tap');
    src.connect(workletNode).connect(silent).connect(audioContext.destination);

    const ringBuf = new Float32Array(WINDOW_SIZE);
    const windowFn = hann(WINDOW_SIZE);
    let writeIdx = 0, filled = 0, hopCount = 0;

    workletNode.port.onmessage = (ev) => {
      const frame = ev.data; // Float32Array(128)
      for (let i=0;i<frame.length;i++){
        ringBuf[writeIdx++] = frame[i];
        if (writeIdx >= WINDOW_SIZE) writeIdx = 0;
        if (filled < WINDOW_SIZE) filled++;
        hopCount++;
        if (hopCount >= HOP_SIZE && filled >= WINDOW_SIZE){
          hopCount = 0;
          analyze();
        }
      }
    };

    function analyze(){
      // rebuild contiguous window
      const start = writeIdx % WINDOW_SIZE;
      const buf = new Float32Array(WINDOW_SIZE);
      const first = ringBuf.subarray(start);
      buf.set(first, 0);
      buf.set(ringBuf.subarray(0, start), first.length);
      // windowing
      for (let i=0;i<WINDOW_SIZE;i++) buf[i] *= windowFn[i];
      // FFT → PCD
      const mags = fftReal(buf);
      const pcd = spectrumToPCD(mags, sampleRate, REF_A4, MIN_HZ, MAX_HZ);
      for (let i=0;i<12;i++){
        window.currentPCD[i] = SMOOTHING*window.currentPCD[i] + (1-SMOOTHING)*pcd[i];
      }
      pcdText.textContent = '[' + Array.from(window.currentPCD).map(v=>v.toFixed(3)).join(', ') + ']';
      drawRing(window.currentPCD);
      window.dispatchEvent(new CustomEvent('pcd', {detail: window.currentPCD}));
      statusEl.textContent = `Running @ ${sampleRate} Hz | N=${WINDOW_SIZE} hop=${HOP_SIZE}`;
    }

    fitCanvas();
    drawRing(window.currentPCD);
  }

  function stop(){
    if (!running) return;
    running = false; startBtn.disabled = false; stopBtn.disabled = true; statusEl.textContent = 'Stopped';
    try { workletNode?.disconnect(); } catch {}
    try { audioContext?.close(); } catch {}
    try { micStream?.getTracks().forEach(t=>t.stop()); } catch {}
  }

  startBtn.addEventListener('click', start, { passive: true });
  stopBtn.addEventListener('click', stop, { passive: true });

  // Initial canvas setup
  fitCanvas(); drawRing(new Float32Array(12));
</script>
</body>
</html>
