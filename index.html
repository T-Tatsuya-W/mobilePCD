<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Mic → PCD (Ring + Tuning Needle + Reactivity)</title>
<style>
  :root { color-scheme: dark light; }
  * { box-sizing: border-box; }
  body{
    margin:0; padding:12px; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:grid; gap:12px; min-height:100svh; grid-template-rows:auto auto 1fr auto;
  }
  header, footer{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  button{
    padding:12px 14px; border-radius:12px; border:1px solid #888; background:transparent; cursor:pointer;
    touch-action:manipulation;
  }
  #status{ opacity:.8 }
  details.settings {
    border:1px solid color-mix(in oklab, currentColor 20%, transparent);
    border-radius:12px; padding:8px 12px;
  }
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:4px 0}
  .row label{min-width:11ch; opacity:.85}
  .row input[type="range"]{ width:220px; }
  .canvas-wrap{ display:grid; place-items:center; width:100%; height:100%; }
  canvas{
    max-width: min(100%, 720px);
    max-height: min(100%, 720px);
    width: 100%;
    height: auto;
    touch-action:none; /* for dragging rotation on mobile */
    border-radius: 16px;
    border: 1px solid color-mix(in oklab, currentColor 30%, transparent);
    background: transparent;
  }
  code{ background:#0001; padding:3px 6px; border-radius:6px }
</style>
</head>
<body>
  <header>
    <button id="start">Start mic</button>
    <button id="stop" disabled>Stop</button>
    <button id="resetRot" title="Reset ring rotation">Reset ring</button>
    <span id="status">Idle</span>
  </header>

  <details class="settings">
    <summary><strong>Settings</strong> ⚙️</summary>
    <div class="row">
      <label for="reactRange">Reactivity</label>
      <input id="reactRange" type="range" min="0.05" max="1.00" step="0.01" value="0.35">
      <span id="reactVal">0.35</span>
      <small>← smoother | snappier →</small>
    </div>
    <div class="row">
      <label for="promRange">Min Prom (dB)</label>
      <input id="promRange" type="range" min="0" max="24" step="0.5" value="6">
      <span id="promVal">6.0 dB</span>
      <small>peak prominence required to show needle</small>
    </div>
    <div class="row">
      <label for="rmsRange">Min RMS</label>
      <input id="rmsRange" type="range" min="0" max="0.02" step="0.0005" value="0.003">
      <span id="rmsVal">0.0030</span>
      <small>gate quiet frames</small>
    </div>
  </details>

  <div class="canvas-wrap">
    <canvas id="ring"></canvas>
  </div>

  <footer style="display:flex;gap:16px;align-items:center;flex-wrap:wrap">
    <div><strong>PCD (C..B):</strong> <code id="pcdText">[0,0,0,0,0,0,0,0,0,0,0,0]</code></div>
    <div id="tuneReadout" style="opacity:.9"></div>
  </footer>

<script type="module">
  // =========================
  // ====== CONFIG HERE ======
  // =========================
  const WINDOW_SIZE = 8192*2;   // larger window helps tuning stability
  const HOP_SIZE    = 2048*2;
  const MIN_HZ      = 50;
  const MAX_HZ      = 5000;
  const REF_A4      = 440;
  const SMOOTHING   = 0.6;

  const RING = {
    innerRadiusRatio: 0.38,
    outerRadiusRatio: 0.95,
    labelRadiusRatio: 0.30,
    gapRadians: 0.02,          // visual gap between wedges
    baseRotation: -Math.PI/2,  // C at 12 o’clock
  };

  // Even-hue color palette (equal S/L; 30° steps)
  const NOTE_LABELS = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const IS_BLACK    = [false,true,false,true,false,false,true,false,true,false,true,false];
  const COLOR = { startHue: 0, sat: 80, light: 55 };
  const PC_HUE = i => (COLOR.startHue + i * 30) % 360;
  const SLOT_BG_ALPHA = 0.10;

  // Tuning needle defaults (some are user-adjustable below)
  const TUNER = {
    enabled: true,
    minHz: 70,
    maxHz: 1800,
    minProminence: 6.0,  // dB (slider)
    minRMS: 0.003,       // (slider)
    reactivity: 0.35,    // 0.05..1.0 (slider) — EMA step for angle smoothing
    needleColor: '#00aaff',
    needleWidth: 3,
    hubRadiusRatio: 0.05,
    tipRadiusRatio: 0.98,
    tailRadiusRatio: 0.20
  };
  // =========================

  // ===== Utilities =====
  const hann = (N) => {
    const w = new Float32Array(N), t = 2*Math.PI/(N-1);
    for (let n=0;n<N;n++) w[n] = 0.5*(1-Math.cos(t*n));
    return w;
  };

  function fftReal(signal){
    let N=1; while (N<signal.length) N<<=1;
    const re = new Float32Array(N), im = new Float32Array(N);
    re.set(signal);
    let j=0;
    for (let i=1;i<N;i++){
      let bit=N>>1;
      for(; j & bit; bit>>=1) j^=bit;
      j^=bit;
      if(i<j){ [re[i],re[j]]=[re[j],re[i]]; [im[i],im[j]]=[im[j],im[i]]; }
    }
    for (let len=2; len<=N; len<<=1){
      const ang=-2*Math.PI/len;
      const wlenRe=Math.cos(ang), wlenIm=Math.sin(ang);
      for(let i=0;i<N;i+=len){
        let wRe=1,wIm=0;
        for(let k=0;k<len/2;k++){
          const uRe=re[i+k], uIm=im[i+k];
          const vRe=re[i+k+len/2]*wRe - im[i+k+len/2]*wIm;
          const vIm=re[i+k+len/2]*wIm + im[i+k+len/2]*wRe;
          re[i+k]=uRe+vRe;       im[i+k]=uIm+vIm;
          re[i+k+len/2]=uRe-vRe; im[i+k+len/2]=uIm-vIm;
          const nwRe=wRe*wlenRe - wIm*wlenIm;
          const nwIm=wRe*wlenIm + wIm*wlenRe;
          wRe=nwRe; wIm=nwIm;
        }
      }
    }
    const mags = new Float32Array(N/2);
    for (let i=0;i<N/2;i++) mags[i]=Math.hypot(re[i],im[i]);
    return mags;
  }

  function spectrumToPCD(mags, sampleRate, a4=440, minHz=50, maxHz=5000){
    const pcd = new Float32Array(12);
    const binHz = sampleRate/(mags.length*2);
    const minBin = Math.max(1, Math.floor(minHz/binHz));
    const maxBin = Math.min(mags.length-1, Math.floor(maxHz/binHz));
    for (let k=minBin;k<=maxBin;k++){
      const f = k*binHz;
      const midi = 69 + 12*Math.log2(f/a4);
      const pc = ((Math.round(midi)%12)+12)%12;
      const w = mags[k]*mags[k]; // power weighting
      pcd[pc]+=w;
    }
    let sum=0; for (let i=0;i<12;i++) sum+=pcd[i];
    if (sum>0) for (let i=0;i<12;i++) pcd[i]/=sum;
    return pcd;
  }

  // Dominant peak estimation with parabolic interpolation around bin k
  function estimatePrimary(mags, sampleRate, minHz, maxHz){
    const N2 = mags.length;               // N/2
    const binHz = sampleRate / (N2*2);    // bin width
    let kMin = Math.max(2, Math.floor(minHz/binHz));
    let kMax = Math.min(N2-3, Math.floor(maxHz/binHz));

    // find max bin
    let k = kMin, maxVal = -1;
    for (let i=kMin;i<=kMax;i++){
      const v = mags[i];
      if (v > maxVal){ maxVal=v; k=i; }
    }
    if (maxVal <= 0) return null;

    // local median for a small neighborhood to compute prominence
    const w = 20; // +/- bins
    let from = Math.max(kMin, k-w), to = Math.min(kMax, k+w);
    const neigh = mags.slice(from, to+1).sort((a,b)=>a-b);
    const med = neigh[Math.floor(neigh.length/2)] + 1e-12;
    const prominenceDb = 20*Math.log10((maxVal+1e-12) / med);

    // parabolic interpolation
    const a = mags[k-1], b = mags[k], c = mags[k+1];
    const denom = (a - 2*b + c) || 1e-12;
    const delta = 0.5 * (a - c) / denom; // shift in bins, usually in [-0.5,0.5]
    const kRef = k + Math.max(-1, Math.min(1, delta));
    const freq = kRef * binHz;

    return { freq, kRef, prominenceDb };
  }

  // ===== DOM / Canvas =====
  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const resetRot = document.getElementById('resetRot');
  const statusEl = document.getElementById('status');
  const pcdText  = document.getElementById('pcdText');
  const tuneEl   = document.getElementById('tuneReadout');
  const canvas   = document.getElementById('ring');
  const ctx      = canvas.getContext('2d', { alpha: true });

  // Settings controls
  const reactRange = document.getElementById('reactRange');
  const reactVal   = document.getElementById('reactVal');
  const promRange  = document.getElementById('promRange');
  const promVal    = document.getElementById('promVal');
  const rmsRange   = document.getElementById('rmsRange');
  const rmsVal     = document.getElementById('rmsVal');

  reactRange.addEventListener('input', () => {
    TUNER.reactivity = parseFloat(reactRange.value);
    reactVal.textContent = TUNER.reactivity.toFixed(2);
  });
  promRange.addEventListener('input', () => {
    TUNER.minProminence = parseFloat(promRange.value);
    promVal.textContent = TUNER.minProminence.toFixed(1) + ' dB';
  });
  rmsRange.addEventListener('input', () => {
    TUNER.minRMS = parseFloat(rmsRange.value);
    rmsVal.textContent = TUNER.minRMS.toFixed(4);
  });

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const css = canvas.getBoundingClientRect();
    canvas.width  = Math.round(css.width * dpr);
    canvas.height = Math.round(css.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
  }
  new ResizeObserver(fitCanvas).observe(canvas);

  // ===== Ring drawing =====
  let userRotation = 0; // radians
  let needleAngleSm = null; // smoothed angle (radians)
  let centsSm = null;       // smoothed cents display
  let lastPrimary = null;   // raw latest reading for UI

  function wedgePath(cx, cy, rInner, rOuter, a0, a1){
    const p = new Path2D();
    p.arc(cx, cy, rOuter, a0, a1);
    p.arc(cx, cy, rInner, a1, a0, true);
    p.closePath();
    return p;
  }
  function pcFillColor(i){ return `hsl(${PC_HUE(i)} ${COLOR.sat}% ${COLOR.light}%)`; }
  function slotBgColor(i){ return `hsla(${PC_HUE(i)} ${COLOR.sat}% ${COLOR.light}%, ${SLOT_BG_ALPHA})`; }

  function drawRing(pcd){
    const { width, height } = canvas.getBoundingClientRect();
    const cx = width/2, cy = height/2;
    const rMin = Math.min(width, height)/2;
    const rInner = rMin * RING.innerRadiusRatio;
    const rOuter = rMin * RING.outerRadiusRatio;
    const rLabel = rMin * RING.labelRadiusRatio;

    ctx.clearRect(0,0,width,height);

    const slice = (Math.PI*2)/12;
    const gap = Math.min(RING.gapRadians, slice*0.3);

    const fontPx = Math.max(11, Math.min(18, Math.round(rMin*0.06)));
    ctx.font = `${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i=0;i<12;i++){
      const a0 = RING.baseRotation + userRotation + i*slice + gap/2;
      const a1 = a0 + slice - gap;

      // slot background
      ctx.fillStyle = slotBgColor(i);
      ctx.fill(wedgePath(cx, cy, rInner, rOuter, a0, a1));

      // active value
      const val = pcd[i];
      if (val > 0.001){
        const rVal = rInner + val*(rOuter - rInner);
        ctx.fillStyle = pcFillColor(i);
        ctx.fill(wedgePath(cx, cy, rInner, rVal, a0, a1));
      }

      // labels with halo
      const mid = (a0+a1)/2;
      const lx = cx + Math.cos(mid)*rLabel;
      const ly = cy + Math.sin(mid)*rLabel;

      ctx.lineWidth = Math.max(2, fontPx/5);
      ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.strokeText(NOTE_LABELS[i], lx, ly);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.strokeText(NOTE_LABELS[i], lx, ly);
      ctx.fillStyle = 'currentColor'; ctx.fillText(NOTE_LABELS[i], lx, ly);

      // subtle dot for black keys
      if (IS_BLACK[i]){
        const dotR = Math.max(2, rMin*0.01);
        ctx.beginPath();
        ctx.arc(cx + Math.cos(mid)*(rInner + (rOuter-rInner)*0.5),
                cy + Math.sin(mid)*(rInner + (rOuter-rInner)*0.5),
                dotR, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fill();
      }
    }

    // Draw tuning needle (smoothed angle)
    if (needleAngleSm != null){
      const hubR  = rMin * TUNER.hubRadiusRatio;
      const tipR  = rMin * TUNER.tipRadiusRatio;
      const tailR = rMin * TUNER.tailRadiusRatio;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(needleAngleSm);
      ctx.strokeStyle = TUNER.needleColor;
      ctx.lineWidth = TUNER.needleWidth;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(tailR, 0);
      ctx.lineTo(tipR, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, hubR, 0, Math.PI*2);
      ctx.fillStyle = 'color-mix(in oklab, currentColor 20%, transparent)';
      ctx.fill();
      ctx.strokeStyle = 'color-mix(in oklab, currentColor 40%, transparent)';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.restore();
    }
  }

  // Angle unwrapping helper: get shortest angular difference in [-π, π]
  function wrapDiff(target, current){
    let d = target - current;
    while (d >  Math.PI) d -= 2*Math.PI;
    while (d < -Math.PI) d += 2*Math.PI;
    return d;
  }

  // ===== Drag to rotate =====
  let dragging=false, lastAngle=0;
  function pointAngle(evt){
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX ?? evt.touches?.[0]?.clientX) - rect.left;
    const y = (evt.clientY ?? evt.touches?.[0]?.clientY) - rect.top;
    const cx = rect.width/2, cy = rect.height/2;
    return Math.atan2(y - cy, x - cx);
  }
  function onPointerDown(e){ e.preventDefault(); dragging=true; lastAngle=pointAngle(e); canvas.setPointerCapture?.(e.pointerId ?? 0); }
  function onPointerMove(e){ if (!dragging) return; const a=pointAngle(e); userRotation += (a-lastAngle); lastAngle=a; drawRing(window.currentPCD); }
  function onPointerUp(e){ dragging=false; canvas.releasePointerCapture?.(e.pointerId ?? 0); }
  if ('onpointerdown' in window){
    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('pointercancel', onPointerUp);
  } else {
    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive:false});
    window.addEventListener('touchmove', onPointerMove, {passive:false});
    window.addEventListener('touchend', onPointerUp);
    window.addEventListener('touchcancel', onPointerUp);
  }
  resetRot.addEventListener('click', ()=>{ userRotation=0; drawRing(window.currentPCD); });

  // ===== Public hook =====
  window.currentPCD = new Float32Array(12);

  // ===== Audio + analysis =====
  let audioContext, workletNode, micStream, running=false, sampleRate=48000;
  const workletURL = URL.createObjectURL(new Blob([`
    class Tap extends AudioWorkletProcessor {
      process(inputs){ const ch = inputs[0][0]; if (ch) this.port.postMessage(ch.slice(0)); return true; }
    }
    registerProcessor('tap', Tap);
  `], {type:'text/javascript'}));

  function frameRms(buf){
    let s=0; for (let i=0;i<buf.length;i++) s += buf[i]*buf[i];
    return Math.sqrt(s / buf.length);
  }

  async function start(){
    if (running) return;
    running = true; startBtn.disabled = true; stopBtn.disabled = false; statusEl.textContent = 'Starting…';

    audioContext = new (window.AudioContext || window.webkitAudioContext)({latencyHint:'interactive'});
    sampleRate = audioContext.sampleRate;
    await audioContext.audioWorklet.addModule(workletURL);

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false },
      video: false
    });

    const src = audioContext.createMediaStreamSource(micStream);
    const silent = audioContext.createGain(); silent.gain.value = 0;
    workletNode = new AudioWorkletNode(audioContext, 'tap');
    src.connect(workletNode).connect(silent).connect(audioContext.destination);

    const ringBuf = new Float32Array(WINDOW_SIZE);
    const windowFn = hann(WINDOW_SIZE);
    let writeIdx = 0, filled = 0, hopCount = 0;

    workletNode.port.onmessage = (ev) => {
      const frame = ev.data; // Float32Array(128)
      for (let i=0;i<frame.length;i++){
        ringBuf[writeIdx++] = frame[i];
        if (writeIdx >= WINDOW_SIZE) writeIdx = 0;
        if (filled < WINDOW_SIZE) filled++;
        hopCount++;
        if (hopCount >= HOP_SIZE && filled >= WINDOW_SIZE){
          hopCount = 0;
          analyze();
        }
      }
    };

    function analyze(){
      // rebuild contiguous window
      const start = writeIdx % WINDOW_SIZE;
      const buf = new Float32Array(WINDOW_SIZE);
      const first = ringBuf.subarray(start);
      buf.set(first, 0);
      buf.set(ringBuf.subarray(0, start), first.length);

      // windowing
      for (let i=0;i<WINDOW_SIZE;i++) buf[i] *= windowFn[i];

      // For gating + tuner
      const rms = frameRms(buf);

      // FFT
      const mags = fftReal(buf);

      // PCD
      const pcd = spectrumToPCD(mags, sampleRate, REF_A4, MIN_HZ, MAX_HZ);

      // Smooth PCD
      for (let i=0;i<12;i++){
        window.currentPCD[i] = SMOOTHING*window.currentPCD[i] + (1-SMOOTHING)*pcd[i];
      }

      // --- Tuning needle estimation (with smoothing controls) ---
      lastPrimary = null;
      if (TUNER.enabled && rms >= TUNER.minRMS){
        const est = estimatePrimary(mags, sampleRate, TUNER.minHz, TUNER.maxHz);
        if (est && est.prominenceDb >= TUNER.minProminence){
          const midiReal = 69 + 12*Math.log2(est.freq / REF_A4);
          const nearest  = Math.round(midiReal);
          const cents    = (midiReal - nearest) * 100; // positive = sharp
          const pc       = ((nearest % 12) + 12) % 12;

          const slice = (Math.PI*2)/12;
          const a0 = RING.baseRotation + userRotation + pc*slice + RING.gapRadians/2;
          const a1 = a0 + slice - RING.gapRadians;
          const mid = (a0+a1)/2;
          const angleRaw = mid + (cents/100) * slice;

          // initialize smoothed state if null
          if (needleAngleSm == null){ needleAngleSm = angleRaw; }
          if (centsSm == null){ centsSm = cents; }

          // EMA smoothing with angle unwrapping
          const step = Math.max(0.05, Math.min(1.0, TUNER.reactivity)); // clamp
          const dAng = wrapDiff(angleRaw, needleAngleSm);
          needleAngleSm = needleAngleSm + step * dAng;
          centsSm = centsSm + step * (cents - centsSm);

          lastPrimary = { cents, centsSm, pc, freq: est.freq, confDb: est.prominenceDb };
        }
      }

      // UI
      pcdText.textContent = '[' + Array.from(window.currentPCD).map(v=>v.toFixed(3)).join(', ') + ']';
      drawRing(window.currentPCD);

      if (lastPrimary){
        const name = NOTE_LABELS[lastPrimary.pc];
        const centsStr = (lastPrimary.centsSm>=0?'+':'') + lastPrimary.centsSm.toFixed(1);
        tuneEl.textContent = `Primary: ${name}  ${centsStr}¢  (~${lastPrimary.freq.toFixed(1)} Hz, ${lastPrimary.confDb.toFixed(1)} dB)`;
      } else {
        // slowly fade needle toward null if no reading
        if (needleAngleSm != null){
          // optional slow decay: reduce influence
          // Here we simply keep last angle; or uncomment to decay:
          // needleAngleSm = null; centsSm = null;
        }
        tuneEl.textContent = '';
      }

      // Event for external consumers
      window.dispatchEvent(new CustomEvent('pcd', {detail: window.currentPCD}));

      statusEl.textContent = `Running @ ${sampleRate} Hz | N=${WINDOW_SIZE} hop=${HOP_SIZE}`;
    }

    fitCanvas();
    drawRing(window.currentPCD);
  }

  function stop(){
    if (!running) return;
    running = false; startBtn.disabled = false; stopBtn.disabled = true; statusEl.textContent = 'Stopped';
    try { workletNode?.disconnect(); } catch {}
    try { audioContext?.close(); } catch {}
    try { micStream?.getTracks().forEach(t=>t.stop()); } catch {}
  }

  startBtn.addEventListener('click', start, { passive: true });
  stopBtn.addEventListener('click', stop, { passive: true });

  // Initial canvas setup + reflect slider defaults
  fitCanvas(); 
  document.getElementById('reactVal').textContent = TUNER.reactivity.toFixed(2);
  document.getElementById('promVal').textContent  = TUNER.minProminence.toFixed(1) + ' dB';
  document.getElementById('rmsVal').textContent   = TUNER.minRMS.toFixed(4);
  drawRing(new Float32Array(12));
</script>
</body>
</html>
