<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DFT & Inverse DFT Test Page</title>
  <style>
    body { font-family: sans-serif; margin: 20px; max-width: 900px; }
    input, button, textarea { width: 100%; margin: 6px 0; }
    textarea { height: 60px; }
    canvas { border: 1px solid #ccc; margin: 10px 0; width: 100%; height: 160px; }
    section { margin-bottom: 28px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h1>DFT & Inverse DFT Test Page</h1>

  <!-- Forward DFT -->
  <section>
    <h2>Forward DFT (PCD → DFTcoef)</h2>
    <label>
      PCD (comma-separated):
      <textarea id="timeInput">1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0</textarea>
    </label>
    <button id="forwardBtn">Compute DFT</button>
    <pre id="dftOutput" class="mono"></pre>
  </section>

  <!-- Full inverse -->
  <section>
    <h2>Inverse DFT (DFTcoef → PCD)</h2>
    <div class="row">
      <label>
        Amplitudes (comma-separated):
        <textarea id="ampInput"></textarea>
      </label>
      <label>
        Phases (comma-separated, radians):
        <textarea id="phaseInput"></textarea>
      </label>
    </div>
    <button id="inverseBtn">Reconstruct Signal</button>
    <pre id="idftOutput" class="mono"></pre>
    <h3>Reconstructed Signal Plot</h3>
    <canvas id="signalCanvas"></canvas>
  </section>

  <!-- Reduced-bins inverse -->
  <section>
    <h2>Inverse DFT with Reduced Bins</h2>
    <p>
      Keeps only bins <strong>0, 3, 5, 7, 9</strong> (within range). All other bins are set to 0.
      Magnitudes for bins <strong>5</strong> and <strong>7</strong> are forced to <strong>1</strong> (phases preserved).
    </p>
    <div class="row">
      <label>
        Reduced Amplitudes (auto-filled):
        <textarea id="sparseAmpInput"></textarea>
      </label>
      <label>
        Reduced Phases (auto-filled):
        <textarea id="sparsePhaseInput"></textarea>
      </label>
    </div>
    <button id="sparseInverseBtn">Reconstruct (Selected Bins)</button>
    <pre id="sparseIdftOutput" class="mono"></pre>
    <h3>Reduced-Bins Reconstructed Plot</h3>
    <canvas id="sparseCanvas"></canvas>
  </section>

  <script type="module">
    function parseInput(str) {
      return str
        .split(',')
        .map(s => parseFloat(s.trim()))
        .filter(v => Number.isFinite(v));
    }

    function forwardDFT(signal) {
  const N = signal.length;
  const amplitude = new Array(N).fill(0);
  const phase = new Array(N).fill(0);

  // --- Compute DFT ---
  for (let k = 0; k < N; k++) {
    let re = 0, im = 0;
    for (let n = 0; n < N; n++) {
      const angle = (-2 * Math.PI * k * n) / N;
      re += signal[n] * Math.cos(angle);
      im += signal[n] * Math.sin(angle);
    }
    amplitude[k] = Math.hypot(re, im);
    phase[k] = Math.atan2(im, re);
  }

  // --- Normalize amplitudes to range [0, 1] ---
  const maxAmp = Math.max(...amplitude);
  const minAmp = Math.min(...amplitude);
  const range = maxAmp - minAmp || 1; // avoid divide-by-zero
  for (let k = 0; k < N; k++) {
    amplitude[k] = (amplitude[k] - minAmp) / range;
  }

  return { amplitude, phase };
}

    function inverseDFT(amplitude, phase) {
      const N = amplitude.length;
      const signal = new Array(N).fill(0);

      for (let n = 0; n < N; n++) {
        let reSum = 0;
        for (let k = 0; k < N; k++) {
          const angle = (2 * Math.PI * k * n) / N;
          // A_k * cos(phi_k) * cos + (-A_k * sin(phi_k) * sin) == A_k * cos(angle - phi_k)
          reSum += amplitude[k] * Math.cos(phase[k]) * Math.cos(angle)
                 - amplitude[k] * Math.sin(phase[k]) * Math.sin(angle);
        }
        signal[n] = reSum / N;
      }
      return signal;
    }

    function plotSignal(data, canvas) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width, height = canvas.height;

      // Handle HiDPI for crisper lines
      const dpr = window.devicePixelRatio || 1;
      if (canvas._lastDpr !== dpr) {
        canvas._lastDpr = dpr;
        const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
        canvas.width = Math.max(1, Math.floor(cssW * dpr));
        canvas.height = Math.max(1, Math.floor(cssH * dpr));
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const maxVal = Math.max(1e-12, ...data.map(v => Math.abs(v)));
      ctx.beginPath();
      for (let i = 0; i < data.length; i++) {
        const x = (i / (data.length - 1)) * (canvas.width - 1);
        const y = canvas.height / 2 - (data[i] / maxVal) * (canvas.height / 2 - 4);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.lineWidth = Math.max(1, (window.devicePixelRatio || 1));
      ctx.strokeStyle = '#1f6feb';
      ctx.stroke();
    }

    function reduceCoefficients(amplitude, phase) {
  const N = amplitude.length;
  const ampR = new Array(N).fill(0);
  const phaseR = new Array(N).fill(0);

  const inRange = k => k >= 0 && k < N;

  // Bin 0 (DC)
  if (inRange(0)) {
    ampR[0] = amplitude[0];
    phaseR[0] = phase[0];
  }

  // Bin 3: copy from source
  if (inRange(3)) {
    ampR[3] = amplitude[3];
    phaseR[3] = phase[3];
  }

  // Bin 5: force magnitude 1, keep original phase
  if (inRange(5)) {
    ampR[5] = 1;
    phaseR[5] = phase[5];
  }

  // Bin 7: force magnitude 1, phase copied from bin 5
  if (inRange(7)) {
    ampR[7] = 1;
    phaseR[7] = inRange(5) ? phase[5] : phase[7];
  }

  // Bin 9: magnitude copied from bin 3, phase copied from bin 3
  if (inRange(9)) {
    ampR[9] = inRange(3) ? amplitude[3] : amplitude[9];
    phaseR[9] = inRange(3) ? phase[3] : phase[9];
  }

  return { ampR, phaseR };
}

    // UI wiring
    const forwardBtn = document.getElementById('forwardBtn');
    const inverseBtn = document.getElementById('inverseBtn');
    const sparseInverseBtn = document.getElementById('sparseInverseBtn');

    forwardBtn.addEventListener('click', () => {
      const timeData = parseInput(document.getElementById('timeInput').value);
      if (timeData.length < 2) {
        alert('Input must have at least 2 numbers.');
        return;
      }

      const { amplitude, phase } = forwardDFT(timeData);

      // Output full DFT
      document.getElementById('dftOutput').textContent =
        'Amplitudes:\n' + amplitude.map(v => v.toFixed(6)).join(', ') +
        '\n\nPhases (radians):\n' + phase.map(v => v.toFixed(6)).join(', ');

      // Autofill full inverse section
      document.getElementById('ampInput').value = amplitude.join(', ');
      document.getElementById('phaseInput').value = phase.join(', ');

      // Prepare reduced-bins arrays and autofill
      const { ampR, phaseR } = reduceCoefficients(amplitude, phase);
      document.getElementById('sparseAmpInput').value = ampR.join(', ');
      document.getElementById('sparsePhaseInput').value = phaseR.join(', ');
    });

    inverseBtn.addEventListener('click', () => {
      const amplitude = parseInput(document.getElementById('ampInput').value);
      const phase = parseInput(document.getElementById('phaseInput').value);
      if (amplitude.length !== phase.length || amplitude.length < 2) {
        alert('Amplitude and phase arrays must be the same length and at least 2.');
        return;
      }

      const timeDomain = inverseDFT(amplitude, phase);
      document.getElementById('idftOutput').textContent =
        'Reconstructed time-domain signal:\n' + timeDomain.map(v => v.toFixed(6)).join(', ');
      plotSignal(timeDomain, document.getElementById('signalCanvas'));
    });

    sparseInverseBtn.addEventListener('click', () => {
      const amplitude = parseInput(document.getElementById('sparseAmpInput').value);
      const phase = parseInput(document.getElementById('sparsePhaseInput').value);
      if (amplitude.length !== phase.length || amplitude.length < 2) {
        alert('Reduced amplitude and phase arrays must be the same length and at least 2.');
        return;
      }

      const timeDomain = inverseDFT(amplitude, phase);
      document.getElementById('sparseIdftOutput').textContent =
        'Reduced-bins reconstructed signal:\n' + timeDomain.map(v => v.toFixed(6)).join(', ');
      plotSignal(timeDomain, document.getElementById('sparseCanvas'));
    });
  </script>
</body>
</html>