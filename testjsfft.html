<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DFT & Inverse DFT Test Page</title>
  <style>
    body { font-family: sans-serif; margin: 20px; max-width: 800px; }
    input, button, textarea { width: 100%; margin: 5px 0; }
    textarea { height: 50px; }
    canvas { border: 1px solid #ccc; margin: 10px 0; width: 100%; height: 150px; }
    section { margin-bottom: 30px; }
  </style>
</head>
<body>
  <h1>DFT & Inverse DFT Test Page</h1>

  <section>
    <h2>Forward DFT (PCD → DFTcoef)</h2>
    <label>
      Time-domain signal (comma-separated):
      <textarea id="timeInput">1, 0, -1, 0, 1, 0, -1, 0, 1, 0, -1, 0</textarea>
    </label>
    <button id="forwardBtn">Compute DFT</button>
    <pre id="dftOutput"></pre>
  </section>

  <section>
    <h2>Inverse DFT (DFTcoef → PCD)</h2>
    <label>
      Amplitudes (comma-separated):
      <textarea id="ampInput"></textarea>
    </label>
    <label>
      Phases (comma-separated, radians):
      <textarea id="phaseInput"></textarea>
    </label>
    <button id="inverseBtn">Reconstruct Signal</button>
    <pre id="idftOutput"></pre>
  </section>

  <h2>Reconstructed Signal Plot</h2>
  <canvas id="signalCanvas"></canvas>

  <script type="module">
    function parseInput(str) {
      return str.split(',').map(s => parseFloat(s.trim())).filter(v => !isNaN(v));
    }

    function forwardDFT(signal) {
      const N = signal.length;
      const amplitude = [];
      const phase = [];

      for (let k = 0; k < N; k++) {
        let re = 0;
        let im = 0;
        for (let n = 0; n < N; n++) {
          const angle = (-2 * Math.PI * k * n) / N;
          re += signal[n] * Math.cos(angle);
          im += signal[n] * Math.sin(angle);
        }
        amplitude.push(Math.sqrt(re * re + im * im));
        phase.push(Math.atan2(im, re));
      }

      return { amplitude, phase };
    }

    function inverseDFT(amplitude, phase) {
      const N = amplitude.length;
      const signal = [];

      for (let n = 0; n < N; n++) {
        let reSum = 0;
        for (let k = 0; k < N; k++) {
          const angle = (2 * Math.PI * k * n) / N;
          reSum += amplitude[k] * Math.cos(phase[k]) * Math.cos(angle) - amplitude[k] * Math.sin(phase[k]) * Math.sin(angle);
        }
        signal.push(reSum / N);
      }

      return signal;
    }

    function plotSignal(data, canvas) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const maxVal = Math.max(...data.map(Math.abs)) || 1;
      ctx.beginPath();
      ctx.moveTo(0, height / 2 - (data[0] / maxVal) * (height / 2));
      data.forEach((val, i) => {
        const x = (i / (data.length - 1)) * width;
        const y = height / 2 - (val / maxVal) * (height / 2);
        ctx.lineTo(x, y);
      });
      ctx.strokeStyle = 'blue';
      ctx.stroke();
    }

    document.getElementById('forwardBtn').addEventListener('click', () => {
      const timeInput = document.getElementById('timeInput').value;
      const timeData = parseInput(timeInput);

      if (timeData.length < 2) {
        alert('Input must have at least 2 numbers.');
        return;
      }

      const { amplitude, phase } = forwardDFT(timeData);
      document.getElementById('dftOutput').textContent =
        'Amplitudes:\n' + amplitude.map(v => v.toFixed(4)).join(', ') +
        '\n\nPhases (radians):\n' + phase.map(v => v.toFixed(4)).join(', ');

      // Autofill inverse section
      document.getElementById('ampInput').value = amplitude.join(', ');
      document.getElementById('phaseInput').value = phase.join(', ');
    });

    document.getElementById('inverseBtn').addEventListener('click', () => {
      const ampInput = document.getElementById('ampInput').value;
      const phaseInput = document.getElementById('phaseInput').value;

      const amplitude = parseInput(ampInput);
      const phase = parseInput(phaseInput);

      if (amplitude.length !== phase.length || amplitude.length < 2) {
        alert('Amplitude and phase arrays must be same length and at least 2.');
        return;
      }

      const timeDomain = inverseDFT(amplitude, phase);
      document.getElementById('idftOutput').textContent =
        'Reconstructed time-domain signal:\n' + timeDomain.map(v => v.toFixed(4)).join(', ');

      plotSignal(timeDomain, document.getElementById('signalCanvas'));
    });
  </script>
</body>
</html>
