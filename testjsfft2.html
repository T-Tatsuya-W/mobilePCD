<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>DFT / iDFT Test (12-bin real rFFT)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { color-scheme: dark light; }
  body { font-family: system-ui, sans-serif; margin: 2rem; max-width: 980px; }
  h2 { margin: 0 0 1rem; }
  .row { display: flex; flex-wrap: wrap; gap: 6px; }
  input[type="number"] { width: 4.3rem; padding: 6px; text-align: right; }
  button { padding: 8px 14px; border: 0; border-radius: 8px; cursor: pointer; }
  button.primary { background: #4b8; color: #000; }
  button.secondary { background: #89c; color: #000; }
  table { border-collapse: collapse; margin-top: 1rem; width: 100%; }
  th, td { border: 1px solid #9994; padding: 6px 8px; text-align: right; }
  th { text-align: center; }
  .section { margin: 1.25rem 0; }
  code { background: #0002; padding: 2px 6px; border-radius: 4px; }
  .muted { opacity: .75; }
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
  @media (max-width: 720px) { .grid { grid-template-columns: 1fr; } }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>
</head>
<body>
<h2>DFT / iDFT Test (Real rFFT, n=12)</h2>

<div class="section">
  <div class="muted">Enter 12 PCD values (they’ll be normalized so the sum is 1):</div>
  <div id="pcdInputs" class="row"></div>
  <div style="margin-top:10px; display:flex; gap:10px; align-items:center;">
    <button class="primary" id="btnForward">Compute Forward (rFFT)</button>
    <span class="muted mono" id="normInfo"></span>
  </div>
</div>

<div class="section grid">
  <div>
    <h3 style="margin:0 0 6px;">Amplitude (k = 0..6)</h3>
    <div id="ampInputs" class="row"></div>
  </div>
  <div>
    <h3 style="margin:0 0 6px;">Phase (radians; k = 0..6)</h3>
    <div id="phaseInputs" class="row"></div>
  </div>
</div>

<div class="section">
  <button class="secondary" id="btnInverse">Reconstruct (iRFFT)</button>
</div>

<div class="section">
  <h3 style="margin:0 0 6px;">Results</h3>
  <div id="results"></div>
</div>

<script>
// ----------------------- Core math (n = 12) -----------------------
const N = 12;
const M = Math.floor(N/2) + 1; // 7 outputs: k=0..6
const TAU = 2 * Math.PI;

// Real-input forward DFT truncated to non-negative freqs (rFFT)
function rfft12(x) {
  const out = new Array(M);
  for (let k = 0; k < M; k++) {
    let re = 0, im = 0;
    const base = -TAU * k / N; // numpy default "backward" norm
    for (let t = 0; t < N; t++) {
      const ang = base * t;
      re += x[t] * Math.cos(ang);
      im += x[t] * Math.sin(ang);
    }
    out[k] = { re, im };
  }
  return out;
}

// Normalize 12-bin PCD to sum=1 (like your Python)
function normalize12(arr) {
  const s = arr.reduce((a,b)=>a+b,0);
  return s === 0 ? arr.slice() : arr.map(v => v / s);
}

// Public: forward analysis → amplitudes & phases (k=0..6)
function getFourierComponent12(pcd) {
  const x = normalize12(pcd);
  const ft = rfft12(x);
  const amp = new Array(M);
  const phs = new Array(M);
  for (let k = 0; k < M; k++) {
    const { re, im } = ft[k];
    amp[k] = Math.hypot(re, im);
    phs[k] = Math.atan2(im, re);
  }
  return { amplitude: amp, phase: phs, normalizedInput: x };
}

// Inverse: given amplitude & phase arrays (k=0..6), rebuild x[0..11]
function irfft12(amplitude, phase) {
  // Build full Hermitian spectrum length N
  const spec = new Array(N).fill(null).map(()=>({re:0, im:0}));

  // Fill 0..M-1 directly from amp/phase
  for (let k = 0; k < M; k++) {
    const re = amplitude[k] * Math.cos(phase[k]);
    const im = amplitude[k] * Math.sin(phase[k]);
    spec[k] = { re, im };
  }
  // Mirror (complex conjugates) for k = 1..M-2
  // Skip DC (k=0) and Nyquist (k=N/2 when N even; here k=6)
  for (let k = 1; k < M - 1; k++) {
    spec[N - k] = { re: spec[k].re, im: -spec[k].im };
  }

  // Inverse DFT (matches numpy irfft scaling): x_t = (1/N) * Σ_k X_k e^{i2πkt/N}
  const x = new Array(N);
  for (let t = 0; t < N; t++) {
    let re = 0, im = 0;
    for (let k = 0; k < N; k++) {
      const ang = TAU * k * t / N;
      const c = Math.cos(ang), s = Math.sin(ang);
      const { re: a, im: b } = spec[k];
      re += a * c - b * s;
      im += a * s + b * c;
    }
    x[t] = re / N; // real part
  }
  return x;
}

// ----------------------- UI wiring -----------------------
const pcdDiv    = document.getElementById('pcdInputs');
const ampDiv    = document.getElementById('ampInputs');
const phaseDiv  = document.getElementById('phaseInputs');
const resultsEl = document.getElementById('results');
const normInfo  = document.getElementById('normInfo');

function numberInput(value, step="any") {
  const i = document.createElement('input');
  i.type = 'number';
  i.step = step;
  i.value = value;
  return i;
}

// 12 PCD inputs (simple ramp default)
const pcdInputs = [];
for (let i = 0; i < N; i++) {
  const inp = numberInput(i < 6 ? i : 0);
  pcdInputs.push(inp);
  pcdDiv.appendChild(inp);
}

// Amp/Phase inputs (k=0..6)
const ampInputs = [], phaseInputs = [];
for (let k = 0; k < M; k++) {
  const a = numberInput(0, "any");
  const p = numberInput(0, "any");
  ampInputs.push(a); phaseInputs.push(p);
  ampDiv.appendChild(a); phaseDiv.appendChild(p);
}

// Forward button
document.getElementById('btnForward').addEventListener('click', () => {
  const pcd = pcdInputs.map(i => parseFloat(i.value) || 0);
  const { amplitude, phase, normalizedInput } = getFourierComponent12(pcd);

  // Fill amp/phase inputs
  for (let k = 0; k < M; k++) {
    ampInputs[k].value = amplitude[k].toFixed(8);
    phaseInputs[k].value = phase[k].toFixed(8);
  }

  const sum = normalizedInput.reduce((a,b)=>a+b,0);
  normInfo.textContent = `Normalized sum = ${sum.toFixed(6)} (should be 1.000000)`;
  renderResultsTable(normalizedInput, amplitude, phase, null, null);
});

// Inverse button
document.getElementById('btnInverse').addEventListener('click', () => {
  // Read current amp/phase inputs (could be edited)
  const amp = ampInputs.map(i => parseFloat(i.value) || 0);
  const phs = phaseInputs.map(i => parseFloat(i.value) || 0);

  // For error, recompute normalized input from the current 12 PCD fields
  const pcd = pcdInputs.map(i => parseFloat(i.value) || 0);
  const xRef = normalize12(pcd);

  const xRec = irfft12(amp, phs);
  const { mae, rmse } = errorStats(xRef, xRec);
  renderResultsTable(xRef, amp, phs, xRec, { mae, rmse });
});

// Helpers to render results
function errorStats(a, b) {
  let se = 0, ae = 0;
  for (let i = 0; i < a.length; i++) {
    const d = (a[i] - b[i]);
    se += d * d; ae += Math.abs(d);
  }
  return { rmse: Math.sqrt(se / a.length), mae: ae / a.length };
}

function renderResultsTable(xRef, amp, phs, xRec=null, err=null) {
  let html = '';
  html += `<table>
    <tr><th>k</th><th>Amplitude</th><th>Phase (rad)</th></tr>`;
  for (let k = 0; k < M; k++) {
    html += `<tr><td>${k}</td><td>${(+amp[k]).toFixed(8)}</td><td>${(+phs[k]).toFixed(8)}</td></tr>`;
  }
  html += `</table>`;

  html += `<div style="height:10px"></div>`;

  html += `<table>
    <tr><th>t</th><th>Input (normalized)</th>${xRec ? '<th>Reconstruction</th><th>Δ</th>' : ''}</tr>`;
  for (let t = 0; t < N; t++) {
    const xi = xRef[t];
    if (xRec) {
      const xr = xRec[t];
      html += `<tr><td>${t}</td><td>${xi.toFixed(8)}</td><td>${xr.toFixed(8)}</td><td>${(xr - xi).toFixed(8)}</td></tr>`;
    } else {
      html += `<tr><td>${t}</td><td>${xRef[t].toFixed(8)}</td></tr>`;
    }
  }
  html += `</table>`;

  if (err) {
    html += `<div class="mono" style="margin-top:8px;">
      RMSE: <code>${err.rmse.toExponential(6)}</code> &nbsp; MAE: <code>${err.mae.toExponential(6)}</code>
    </div>`;
  }

  resultsEl.innerHTML = html;
}

// Initial render (no results yet)
renderResultsTable(new Array(N).fill(0), new Array(M).fill(0), new Array(M).fill(0));

</script>
</body>
</html>
